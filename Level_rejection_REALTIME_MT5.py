import time
import pandas as pd
import numpy as np
import winsound

current_time = time.strftime('%H:%M:%S')


log_file_reading_interval = 1       # File reading interval (sec)

# ************************************** ORDER PARAMETERS *******************************************************

volume_value = 0.01                 # 1000 MAX for stocks. Used only in AU3 (MT5 assigns volume itself)
risk_reward = 1                     # Risk/Reward ratio
stop_loss_offset = 0               # Is added to SL for Shorts and subtracted for Longs (can be equal to spread)

# **************************************************************************************************************

# +------------------------------------------------------------------+
# FILE TRANSMIT PATHS
# +------------------------------------------------------------------+

mt5_account_number = 258    # LAST 3 DIGITS OF MT5 ACCOUNT. MUST BE CHANGED BEFORE BUILDING EXE

# MT5 directory with OHLC log file (logging on active timeframe):
mt5_logging_file_path = (
    f'C:/Users/Liikurserv/AppData/Roaming/MetaQuotes/Terminal/'
    f'30B7687250B3662E635CFEBC979C306C/MQL5/Files/'    # HASH FOLDER MUST BE CHANGED BEFORE EXE BUILD
    f'OHLCVData_{mt5_account_number}.csv'
)

# File with signal generated by Python script
buy_sell_signals_for_mt5_filepath = (
     f'C:/Users/Liikurserv/AppData/Roaming/MetaQuotes/Terminal/'
     f'30B7687250B3662E635CFEBC979C306C/MQL5/Files/'    # HASH FOLDER MUST BE CHANGED BEFORE EXE BUILD
     f'buy_sell_signals_from_python_level.txt'
     )

try:
    buy_signal_discovered = False                   # MUST BE FALSE BEFORE ENTERING MAIN LOOP
    sell_signal_discovered = False                  # MUST BE FALSE BEFORE ENTERING MAIN LOOP

    while True:                                     # Main loop beginning

        # +------------------------------------------------------------------+
        # DATAFRAME CREATION
        # +------------------------------------------------------------------+
        def get_dataframe_from_file():
            log_df = pd.read_csv(mt5_logging_file_path, sep=';', encoding='utf-16', engine='python')
            return log_df

        dataframe_from_log = get_dataframe_from_file()

        # Assigning columns names
        new_column_names = ['Ticker', 'Timeframe', 'Datetime', 'Open', 'High', 'Low', 'Close', 'Volume']
        dataframe_from_log.columns = new_column_names
        # print('Original dataframe: \n', dataframe_from_log)

        dataframe_from_log.set_index('Datetime', inplace=True)
        dataframe_from_log = dataframe_from_log.loc[:, ['Ticker', 'Open', 'High', 'Low', 'Close']]
        # print(dataframe_from_log.info())
        # print(dataframe_from_log)

        # Last candle OHLC
        try:
            last_candle_open = dataframe_from_log['Open'].iloc[-1]
            last_candle_high = dataframe_from_log['High'].iloc[-1]
            last_candle_low = dataframe_from_log['Low'].iloc[-1]
            last_candle_close = dataframe_from_log['Close'].iloc[-1]
            ticker = dataframe_from_log['Ticker'].iloc[-1]
        except IndexError:
            print("Must be at least two rows in the source file")

        # +------------------------------------------------------------------+
        # LEVELS DISCOVERY
        # +------------------------------------------------------------------+


        def find_levels(filtered_df):
            # print('Incoming dataframe: \n', filtered_df)

            levels_startpoints_tuples = []
            levels_endpoints_tuples = []

            level_discovery_signal = []
            level_discovery_signal.insert(0, None)
            level_discovery_signal.insert(1, None)

            sr_levels = []
            support_levels = []
            resistance_levels = []

            # Support levels
            for i in range(2, len(filtered_df) - 2):
                if (filtered_df['Low'][i] < filtered_df['Low'][i - 1]) and \
                        (filtered_df['Low'][i] < filtered_df['Low'][i + 1]) and \
                        (filtered_df['Low'][i + 1] < filtered_df['Low'][i + 2]) and \
                        (filtered_df['Low'][i - 1] < filtered_df['Low'][i - 2]):
                    datetime_1 = filtered_df.index[i]
                    price_level_1 = filtered_df['Low'][i]
                    datetime_2 = filtered_df.index[-1]
                    price_level_2 = filtered_df['Low'][i]

                    if not is_near_level(price_level_1, levels_startpoints_tuples, filtered_df):
                        levels_startpoints_tuples.append((datetime_1, price_level_1))
                        levels_endpoints_tuples.append((datetime_2, price_level_2))

                        sr_levels.append(price_level_1)  # SR levels
                        support_levels.append(price_level_1)
                        level_discovery_signal.append(0)
                    else:
                        level_discovery_signal.append(None)

                # Resistance levels
                elif ((filtered_df['High'][i] > filtered_df['High'][i - 1]) and
                      (filtered_df['High'][i] > filtered_df['High'][i + 1]) and
                      (filtered_df['High'][i + 1] > filtered_df['High'][i + 2]) and
                      (filtered_df['High'][i - 1] > filtered_df['High'][i - 2])):
                    datetime_1 = filtered_df.index[i]
                    price_level_1 = filtered_df['High'][i]
                    datetime_2 = filtered_df.index[-1]
                    price_level_2 = filtered_df['High'][i]

                    if not is_near_level(price_level_1, levels_startpoints_tuples, filtered_df):
                        levels_startpoints_tuples.append((datetime_1, price_level_1))
                        levels_endpoints_tuples.append((datetime_2, price_level_2))

                        sr_levels.append(price_level_1)  # SR levels
                        resistance_levels.append(price_level_1)
                        level_discovery_signal.append(0)
                    else:
                        level_discovery_signal.append(None)

                else:
                    level_discovery_signal.append(None)

            level_discovery_signal.extend([None, None])  # Appending two elements to the end, to match Dataframe length

            # print('level_discovery_signal: \n', level_discovery_signal)
            level_discovery_signals_series = pd.Series(level_discovery_signal)
            # level_discovery_signals_series.index = df['Date']

            return level_discovery_signals_series, sr_levels


        def is_near_level(value, levels, df):
            average = np.mean(df['High'] - df['Low'])
            return any(abs(value - level) < average for _, level in levels)


        level_discovery_signals_series_out, sr_levels_out = find_levels(dataframe_from_log)
        print('---------------------------------------------------------------')
        print('SR Levels: \n', sr_levels_out)

        # pattern_signal_list = [0, 0, 0, 0, 0, -100]
        # pattern_signal = pd.Series(pattern_signal_list)     # hardcoded a series for debugging

        # print(f'Pattern signals (last 10): {list(pattern_signal)[-10:]}')

        #  ----------------------------------------------------------------------------------------------
        #  LEVEL REJECTION SIGNALS
        #  ----------------------------------------------------------------------------------------------


        def level_rejection_signals(df, sr_levels, level_discovery_signals_series):
            rejection_signals = []
            df.reset_index(inplace=True)
            discovered = False  # Flag to track if level was discovered
            for index, row in df.iterrows():
                if pd.notna(level_discovery_signals_series[index]):
                    discovered = True  # Set the flag if level was discovered
                if discovered:
                    previous_close = df.iloc[index - 1]['Close']
                    current_candle_close = row['Close']
                    current_candle_high = row['High']
                    current_candle_low = row['Low']

                    signal = None

                    for level in sr_levels:

                        if previous_close < level:  # Check if the previous close was below the resistance level
                            if current_candle_high > level:  # Price has crossed above resistance level
                                if current_candle_close < level:  # but closed below
                                    signal = -100
                                    break

                        elif previous_close > level:  # Check if the previous close was above the support level
                            if current_candle_low < level:  # Price has crossed below support level
                                if current_candle_close > level:  # but closed above
                                    signal = 100
                                    break
                    rejection_signals.append(signal)

                else:
                    rejection_signals.append(None)  # Append None for indices before discovery

            # print('Rejection_signals_list: \n', rejection_signals)
            # rejection_signals_series = pd.Series(rejection_signals)
            return rejection_signals

        # RESULTING LEVEL REJECTION SIGNALS:
        rejection_signals_list_outside = (
            level_rejection_signals(dataframe_from_log, sr_levels_out, level_discovery_signals_series_out)
        )
        print(f'Rejection_signals_list: \n', rejection_signals_list_outside[-10:])
        print('---------------------------------------------------------------')
        # print('Level_discovery_signals: \n', level_discovery_signals_series_out)

        # +------------------------------------------------------------------+
        # BUY ORDER LOGIC
        # +------------------------------------------------------------------+
        def send_buy_sell_orders(buy_signal, sell_signal):
            if rejection_signals_list_outside[-1] == 0:
                buy_signal, sell_signal = False, False      # Set Flags to False after signal has been discovered

            if rejection_signals_list_outside[-1] == 100 and not buy_signal:
                winsound.PlaySound('chord.wav', winsound.SND_FILENAME)
                print()
                print('▲ ▲ ▲ Buy signal discovered! ▲ ▲ ▲'.upper())

                # ORDER PARAMETERS
                stop_loss_price = round(last_candle_low - stop_loss_offset, 3)
                take_profit_price = round((((last_candle_close - stop_loss_price)
                                            * risk_reward) + last_candle_close) + stop_loss_offset, 3)

                line_order_parameters = f'{ticker},Buy,{stop_loss_price},{take_profit_price}'

                with open(buy_sell_signals_for_mt5_filepath, 'w', encoding='utf-8') as file:
                    file.writelines(line_order_parameters)

                buy_signal = True  # Setting flag back to TRUE
            # +------------------------------------------------------------------+
            # SELL ORDER LOGIC
            # +------------------------------------------------------------------+

            # +------------------------------------------------------------------+
            # Creating file for MT5 to read
            # +------------------------------------------------------------------+

            if rejection_signals_list_outside[-1] == 0:  # Set Flags to False after signal has been discovered
                buy_signal, sell_signal = False, False

            if rejection_signals_list_outside[-1] == -100 and not sell_signal:
                winsound.PlaySound('chord.wav', winsound.SND_FILENAME)
                print()
                print('▼ ▼ ▼ Sell signal discovered! ▼ ▼ ▼'.upper())

                # ORDER PARAMETERS
                stop_loss_price = round(last_candle_high + stop_loss_offset)
                take_profit_price = round((last_candle_close - ((stop_loss_price - last_candle_close) *
                                                                risk_reward)) + stop_loss_offset, 3)

                line_order_parameters = f'{ticker},Sell,{stop_loss_price},{take_profit_price}'

                with open(buy_sell_signals_for_mt5_filepath, 'w', encoding='utf-8') as file:
                    file.writelines(line_order_parameters)

                sell_signal = True  # Setting flag back to TRUE

            return buy_signal, sell_signal


        buy_signal_discovered, sell_signal_discovered = (
            send_buy_sell_orders(buy_signal_discovered, sell_signal_discovered))

        time.sleep(log_file_reading_interval)   # Pause between reading


except KeyboardInterrupt:
    print()
    print('Program stopped manually')   # Catching 'Stop' error
